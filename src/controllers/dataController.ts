/*
 * Copyright (c) 2025 The Ontario Institute for Cancer Research. All rights reserved
 *
 * This program and the accompanying materials are made available under the terms of
 * the GNU Affero General Public License v3.0. You should have received a copy of the
 * GNU Affero General Public License along with this program.
 *  If not, see <http://www.gnu.org/licenses/>.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import { DataRecordNested, isDataRecordValue, SubmittedDataResponse, VIEW_TYPE } from '@overture-stack/lyric';

import { asArray, convertToViewType } from '@/common/formatUtils.js';
import { getDataById } from '@/common/validation/data-validation.js';
import { env } from '@/config/envConfig.js';
import { lyricProvider } from '@/core/provider.js';
import { getDbInstance } from '@/db/index.js';
import { generateHash } from '@/internal/id-manager/utils.js';
import { validateRequest } from '@/middleware/requestValidation.js';
import iimService from '@/service/idManagerService.js';

const defaultPage = 1;
const defaultPageSize = 20;
const defaultView = VIEW_TYPE.Values.flat;

const getDataIdExists = validateRequest(getDataById, async (req, res, next) => {
	const db = getDbInstance();
	const iimRepo = iimService(db);

	try {
		const { id, entityName } = req.params;

		const idConfigResult = await iimRepo.getIIMConfig(entityName);

		//  Check if entityName exists
		if (!idConfigResult[0]) {
			res.status(200).send(false);
			return;
		}

		const idmHash = generateHash(String(id), env.ID_MANAGER_SECRET);

		const generatedIdentifierResult = await iimRepo.getIDByHash(idmHash);

		// Check if the hash has been generated for ANY entity
		if (!generatedIdentifierResult[0]) {
			res.status(200).send(false);
			return;
		}

		// Check if both the idConfigResult id matches the configId in the generatedIdentifierResult
		if (generatedIdentifierResult[0]?.configId !== idConfigResult[0]?.id) {
			res.status(200).send(false);
			return;
		}

		res.status(200).send(true);
		return;
	} catch (exception) {
		next(exception);
	}
});

const getCategoryById = validateRequest(
	lyricProvider.utils.schema.dataGetByCategoryRequestSchema,
	async (req, res, next) => {
		try {
			const categoryId = Number(req.params.categoryId);
			// query params
			const entityName = asArray(req.query.entityName || []);
			const page = parseInt(String(req.query.page)) || defaultPage;
			const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
			const view = convertToViewType(req.query.view) || defaultView;

			// Send submission data, organized by entity.
			const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByCategory(
				categoryId,
				{ page, pageSize },
				{ entityName, view },
			);

			// Reform lyric response to include internal ID's generated by the IIM
			const formattedResult = await SanitizeLyricIdsWithInternal(submitResult.result);

			return res.status(200).send({ ...submitResult, result: formattedResult });
		} catch (error) {
			next(error);
		}
	},
);

const getCategoryBySystemId = validateRequest(
	lyricProvider.utils.schema.dataGetBySystemIdRequestSchema,
	async (req, res, next) => {
		try {
			const categoryId = Number(req.params.categoryId);
			// query params
			const systemId = req.params.systemId;
			const view = convertToViewType(String(req.query.view)) || defaultView;

			// Send submission data, organized by entity.
			const submitResult = await lyricProvider.services.submittedData.getSubmittedDataBySystemId(categoryId, systemId, {
				view,
			});

			if (!submitResult.result) {
				res.status(404).send(submitResult.metadata.errorMessage);
				return;
			}
			// Reform lyric response to include internal ID's generated by the IIM
			const formattedResult = await SanitizeLyricIdsWithInternal([submitResult.result]);

			return res.status(200).send({ ...submitResult, result: formattedResult[0] });
		} catch (error) {
			next(error);
		}
	},
);

const getCategoryByOrganization = validateRequest(
	lyricProvider.utils.schema.dataGetByOrganizationRequestSchema,
	async (req, res, next) => {
		try {
			const categoryId = Number(req.params.categoryId);
			const organization = req.params.organization;

			// query parameters
			const entityName = asArray(req.query.entityName || []);
			const page = parseInt(String(req.query.page)) || defaultPage;
			const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
			const view = convertToViewType(String(req.query.view)) || defaultView;

			// Send submission data, organized by entity.
			const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByOrganization(
				categoryId,
				organization,
				{
					page,
					pageSize,
				},
				{ entityName, view },
			);

			if (!submitResult.result) {
				res.status(404).send(submitResult.metadata.errorMessage);
				return;
			}
			// Reform lyric response to include internal ID's generated by the IIM
			const formattedResult = await SanitizeLyricIdsWithInternal(submitResult.result);

			return res.status(200).send({ ...submitResult, result: formattedResult });
		} catch (error) {
			next(error);
		}
	},
);

const getSubmittedDataByQuery = validateRequest(
	lyricProvider.utils.schema.dataGetByQueryRequestSchema,
	async (req, res, next) => {
		try {
			const categoryId = Number(req.params.categoryId);
			const organization = req.params.organization;
			const sqon = lyricProvider.utils.convertSqonToQuery.parseSQON(req.body);

			// query parameters
			const entityName = asArray(req.query.entityName || []);
			const page = parseInt(String(req.query.page)) || defaultPage;
			const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
			const view = convertToViewType(String(req.query.view)) || defaultView;

			// Send submission data, organized by entity.
			const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByOrganization(
				categoryId,
				organization,
				{
					page,
					pageSize,
				},
				{ sqon, entityName, view },
			);

			// Reform lyric response to include internal ID's generated by the IIM
			const formattedResult = await SanitizeLyricIdsWithInternal(submitResult.result);

			return res.status(200).send({ ...submitResult, result: formattedResult });
		} catch (error) {
			next(error);
		}
	},
);

const getSubmittedDataStream = validateRequest(
	lyricProvider.utils.schema.dataGetByCategoryRequestSchema,
	async (req, res, next) => {
		try {
			const categoryId = Number(req.params.categoryId);
			const entityName = asArray(req.query.entityName || []);
			const view = convertToViewType(String(req.query.view)) || defaultView;

			res.setHeader('Transfer-Encoding', 'chunked');
			res.setHeader('Content-Type', 'application/x-ndjson');

			for await (const data of lyricProvider.services.submittedData.getSubmittedDataByCategoryStream(categoryId, {
				view,
				entityName,
			})) {
				// Reform lyric response to include internal ID's generated by the IIM
				const result = await SanitizeLyricIdsWithInternal([data]);

				res.write(JSON.stringify(result[0]) + '\n');
			}

			return res.end();
		} catch (error) {
			next(error);
		}
	},
);

/**
 *	Function that takes in lyric SubmittedDataResponse[] and applies the transformer to all its array values
 * @returns SubmittedDataResponse replacing "data" with the sanitized sensitive fields with `internalId`
 */
const SanitizeLyricIdsWithInternal = async (submittedResult: SubmittedDataResponse[]) => {
	const db = getDbInstance();
	const iimRepo = iimService(db);
	const iimConfigs = await iimRepo.getAllIIMConfigs();
	const fieldNamesToAdd = new Set(iimConfigs.map((config) => config.fieldName));

	const formatSubmittedResult = submittedResult.map(async (result) => {
		return { ...result, data: await TransformerFunction(result.data, fieldNamesToAdd, iimRepo) };
	});

	return Promise.all(formatSubmittedResult);
};

/**
 *	Recursive function that takes in DataRecordNested and adds the generated internal id's of entities determined from the the IIM config that was generated from the IIM service
 * @param dataRecord
 * @param fieldNames Fieldname values to replace with internalId
 * @param iimRepo iim service to query for internalId's
 * @returns Mutated Promise of DataRecordNested with field `internalId` injected with original entities
 */
const TransformerFunction = async (
	dataRecord: DataRecordNested,
	fieldNamesToAdd: Set<string>,
	iimRepo: ReturnType<typeof iimService>,
) => {
	const processInternalValue = async (
		dataRecordValue: DataRecordNested,
	): Promise<DataRecordNested | DataRecordNested[]> => {
		// The first call will always be DataRecordNested object
		// the conditions in the Object.entries loop will check if other key/value pairs are isDataRecordValue or an DataRecordNested[] before recursive call
		const result: DataRecordNested = {};

		for (const [key, currentValue] of Object.entries(dataRecordValue)) {
			// if current key of dataRecordValue is a key that has a generated ID, then start internal id inject logic
			if (fieldNamesToAdd.has(key)) {
				const hashedFieldName = generateHash(`${dataRecordValue[key]}`, env.ID_MANAGER_SECRET);
				const generatedIdResult = await iimRepo.getIDByHash(hashedFieldName);

				if (generatedIdResult[0] && generatedIdResult[0].internalId) {
					result[generatedIdResult[0].internalId] = generatedIdResult[0]?.generatedId; // Add PCGL internal id
					result[key] = currentValue; // Persist original id
					continue;
				}
			}

			// check if its a dataRecordValue, if yes, then just define result to current key/value
			if (isDataRecordValue(currentValue)) {
				result[key] = currentValue;
				continue;
			}

			// If its an array, then there is possible more objects to search for sensitive data, recursive call
			if (Array.isArray(currentValue)) {
				result[key] = (await Promise.all(currentValue.map(processInternalValue))).flat();
				continue;
			}

			// This means the object dataRecordValue has another object nested, apply another recursive call
			result[key] = await processInternalValue(currentValue);
		}

		return result;
	};

	return await processInternalValue(dataRecord);
};

export default {
	getDataIdExists,
	getCategoryById,
	getCategoryBySystemId,
	getCategoryByOrganization,
	getSubmittedDataByQuery,
	getSubmittedDataStream,
};
