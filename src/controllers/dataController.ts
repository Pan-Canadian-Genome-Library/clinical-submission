/*
 * Copyright (c) 2025 The Ontario Institute for Cancer Research. All rights reserved
 *
 * This program and the accompanying materials are made available under the terms of
 * the GNU Affero General Public License v3.0. You should have received a copy of the
 * GNU Affero General Public License along with this program.
 *  If not, see <http://www.gnu.org/licenses/>.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import { SubmittedDataResponse, VIEW_TYPE } from '@overture-stack/lyric';
import {
	dataGetByCategoryRequestSchema,
	dataGetByOrganizationRequestSchema,
	dataGetByQueryRequestSchema,
	dataGetBySystemIdRequestSchema,
} from '@overture-stack/lyric/dist/src/utils/schemas.js';

import { asArray, convertToViewType } from '@/common/formatUtils.js';
import { getDataById } from '@/common/validation/data-validation.js';
import { env } from '@/config/envConfig.js';
import { lyricProvider } from '@/core/provider.js';
import { getDbInstance } from '@/db/index.js';
import { generateHash } from '@/internal/id-manager/utils.js';
import { validateRequest } from '@/middleware/requestValidation.js';
import iimService from '@/service/idManagerService.js';

const defaultPage = 1;
const defaultPageSize = 20;
const defaultView = VIEW_TYPE.Values.flat;

const getDataIdExists = validateRequest(getDataById, async (req, res, next) => {
	const db = getDbInstance();
	const iimRepo = iimService(db);

	try {
		const { id, entityName, parentId } = req.params;

		const idConfigResult = await iimRepo.getIIMConfig(entityName);

		//  Check if entityName exists
		if (!idConfigResult[0]) {
			res.status(404).send(false);
			return;
		}

		const idmHash = generateHash(String(id), env.ID_MANAGER_SECRET);

		const generatedIdentifierResult = await iimRepo.getIDByHash(idmHash, parentId);

		// Check if the hash has been generated for ANY entity
		if (!generatedIdentifierResult[0]) {
			res.status(200).send(false);
			return;
		}

		//  Check if parentId exists, if yes, that means getIDByHash also searched for its internal id(parentId)
		//    If generatedIdentifierResult has a value with lookup with BOTH idmHash and parentId, then it exists
		if (parentId && generatedIdentifierResult[0]) {
			res.status(200).send(true);
			return;
		}

		// Check if both the idConfigResult id matches the configId in the generatedIdentifierResult
		if (generatedIdentifierResult[0]?.configId !== idConfigResult[0]?.id) {
			res.status(200).send(false);
			return;
		}

		res.status(200).send(true);
		return;
	} catch (exception) {
		next(exception);
	}
});

export const getCategoryById = validateRequest(dataGetByCategoryRequestSchema, async (req, res, next) => {
	try {
		const categoryId = Number(req.params.categoryId);
		// query params
		const entityName = asArray(req.query.entityName || []);
		const page = parseInt(String(req.query.page)) || defaultPage;
		const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
		const view = convertToViewType(req.query.view) || defaultView;

		// Send submission data, organized by entity.
		const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByCategory(
			categoryId,
			{ page, pageSize },
			{ entityName, view },
		);

		// Reform lyric response to include internal ID's generated by the IIM
		const formattedResult = await FormatLyricDataToPCGLResponse(submitResult.result);

		return res.status(200).send({ ...submitResult, result: formattedResult });
	} catch (error) {
		next(error);
	}
});

export const getCategoryBySystemId = validateRequest(dataGetBySystemIdRequestSchema, async (req, res, next) => {
	try {
		const categoryId = Number(req.params.categoryId);
		// query params
		const systemId = req.params.systemId;
		const view = convertToViewType(String(req.query.view)) || defaultView;

		// Send submission data, organized by entity.
		const submitResult = await lyricProvider.services.submittedData.getSubmittedDataBySystemId(categoryId, systemId, {
			view,
		});

		if (!submitResult.result) {
			res.status(404).send(submitResult.metadata.errorMessage);
			return;
		}
		// Reform lyric response to include internal ID's generated by the IIM
		const formattedResult = await FormatLyricDataToPCGLResponse([submitResult.result]);

		return res.status(200).send({ ...submitResult, result: formattedResult[0] });
	} catch (error) {
		next(error);
	}
});

export const getCategoryByOrganization = validateRequest(dataGetByOrganizationRequestSchema, async (req, res, next) => {
	try {
		const categoryId = Number(req.params.categoryId);
		const organization = req.params.organization;

		// query parameters
		const entityName = asArray(req.query.entityName || []);
		const page = parseInt(String(req.query.page)) || defaultPage;
		const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
		const view = convertToViewType(String(req.query.view)) || defaultView;

		// Send submission data, organized by entity.
		const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByOrganization(
			categoryId,
			organization,
			{
				page,
				pageSize,
			},
			{ entityName, view },
		);

		if (!submitResult.result) {
			res.status(404).send(submitResult.metadata.errorMessage);
			return;
		}
		// Reform lyric response to include internal ID's generated by the IIM
		const formattedResult = await FormatLyricDataToPCGLResponse(submitResult.result);

		return res.status(200).send({ ...submitResult, result: formattedResult });
	} catch (error) {
		next(error);
	}
});

export const getSubmittedDataByQuery = validateRequest(dataGetByQueryRequestSchema, async (req, res, next) => {
	try {
		const categoryId = Number(req.params.categoryId);
		const organization = req.params.organization;

		// query parameters
		const entityName = asArray(req.query.entityName || []);
		const page = parseInt(String(req.query.page)) || defaultPage;
		const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
		const view = convertToViewType(String(req.query.view)) || defaultView;

		// Send submission data, organized by entity.
		const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByOrganization(
			categoryId,
			organization,
			{
				page,
				pageSize,
			},
			{ entityName, view },
		);

		// Reform lyric response to include internal ID's generated by the IIM
		const formattedResult = await FormatLyricDataToPCGLResponse(submitResult.result);

		return res.status(200).send({ ...submitResult, result: formattedResult });
	} catch (error) {
		next(error);
	}
});

/**
 *	Formatting function that takes in lyric SubmittedDataResponse[] and inserts an additional field `internalId`
 * @param submittedResult
 * @returns
 */
const FormatLyricDataToPCGLResponse = async (submittedResult: SubmittedDataResponse[]) => {
	const db = getDbInstance();
	const iimRepo = iimService(db);
	const iimConfigs = await iimRepo.getAllIIMConfigs();

	// Grab all fieldname and entityName config values
	const iimConfigArray = iimConfigs.map((config) => {
		return {
			entityName: config.entityName,
			fieldName: config.fieldName,
		};
	});

	const formatSubmittedResult = submittedResult.map(async (result) => {
		let internalId;

		for (const config of iimConfigArray) {
			if (config.entityName === result.entityName) {
				const hashedFieldName = generateHash(`${result.data[config.fieldName]}`, env.ID_MANAGER_SECRET);
				const generatedIdResult = await iimRepo.getIDByHash(hashedFieldName);

				internalId = generatedIdResult[0]?.generatedId;
			}
		}
		return { ...result, internalId };
	});

	return Promise.all(formatSubmittedResult);
};

export default {
	getDataIdExists,
	getCategoryById,
	getCategoryBySystemId,
	getCategoryByOrganization,
	getSubmittedDataByQuery,
};
