/*
 * Copyright (c) 2025 The Ontario Institute for Cancer Research. All rights reserved
 *
 * This program and the accompanying materials are made available under the terms of
 * the GNU Affero General Public License v3.0. You should have received a copy of the
 * GNU Affero General Public License along with this program.
 *  If not, see <http://www.gnu.org/licenses/>.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import { DataRecordNested, SubmittedDataResponse, VIEW_TYPE } from '@overture-stack/lyric';
import {
	dataGetByCategoryRequestSchema,
	dataGetByOrganizationRequestSchema,
	dataGetByQueryRequestSchema,
	dataGetBySystemIdRequestSchema,
} from '@overture-stack/lyric/dist/src/utils/schemas.js';

import { asArray, convertToViewType } from '@/common/formatUtils.js';
import { getDataById } from '@/common/validation/data-validation.js';
import { env } from '@/config/envConfig.js';
import { lyricProvider } from '@/core/provider.js';
import { getDbInstance } from '@/db/index.js';
import { generateHash } from '@/internal/id-manager/utils.js';
import { validateRequest } from '@/middleware/requestValidation.js';
import iimService, { IIMService } from '@/service/idManagerService.js';

const defaultPage = 1;
const defaultPageSize = 20;
const defaultView = VIEW_TYPE.Values.flat;

const getDataIdExists = validateRequest(getDataById, async (req, res, next) => {
	const db = getDbInstance();
	const iimRepo = iimService(db);

	try {
		const { id, entityName } = req.params;
		const { parentId } = req.query;

		const idConfigResult = await iimRepo.getIIMConfig(entityName);

		//  Check if entityName exists
		if (!idConfigResult[0]) {
			res.status(200).send(false);
			return;
		}

		const idmHash = generateHash(String(id), env.ID_MANAGER_SECRET);

		const generatedIdentifierResult = await iimRepo.getIDByHash(idmHash, parentId);

		// Check if the hash has been generated for ANY entity
		if (!generatedIdentifierResult[0]) {
			res.status(200).send(false);
			return;
		}

		//  Check if parentId exists, if yes, that means getIDByHash also searched for its internal id(parentId) so if generatedIdentifierResult has a value with lookup with BOTH idmHash and parentId, then it exists
		if (parentId && generatedIdentifierResult[0]) {
			res.status(200).send(true);
			return;
		}

		// Check if both the idConfigResult id matches the configId in the generatedIdentifierResult
		if (generatedIdentifierResult[0]?.configId !== idConfigResult[0]?.id) {
			res.status(200).send(false);
			return;
		}

		res.status(200).send(true);
		return;
	} catch (exception) {
		next(exception);
	}
});

export const getCategoryById = validateRequest(dataGetByCategoryRequestSchema, async (req, res, next) => {
	try {
		const categoryId = Number(req.params.categoryId);
		// query params
		const entityName = asArray(req.query.entityName || []);
		const page = parseInt(String(req.query.page)) || defaultPage;
		const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
		const view = convertToViewType(req.query.view) || defaultView;

		// Send submission data, organized by entity.
		const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByCategory(
			categoryId,
			{ page, pageSize },
			{ entityName, view },
		);

		// Reform lyric response to include internal ID's generated by the IIM
		const formattedResult = await SanitizeLyricIdsWithInternal(submitResult.result);

		return res.status(200).send({ ...submitResult, result: formattedResult });
	} catch (error) {
		next(error);
	}
});

export const getCategoryBySystemId = validateRequest(dataGetBySystemIdRequestSchema, async (req, res, next) => {
	try {
		const categoryId = Number(req.params.categoryId);
		// query params
		const systemId = req.params.systemId;
		const view = convertToViewType(String(req.query.view)) || defaultView;

		// Send submission data, organized by entity.
		const submitResult = await lyricProvider.services.submittedData.getSubmittedDataBySystemId(categoryId, systemId, {
			view,
		});

		if (!submitResult.result) {
			res.status(404).send(submitResult.metadata.errorMessage);
			return;
		}
		// Reform lyric response to include internal ID's generated by the IIM
		const formattedResult = await SanitizeLyricIdsWithInternal([submitResult.result]);

		return res.status(200).send({ ...submitResult, result: formattedResult[0] });
	} catch (error) {
		next(error);
	}
});

export const getCategoryByOrganization = validateRequest(dataGetByOrganizationRequestSchema, async (req, res, next) => {
	try {
		const categoryId = Number(req.params.categoryId);
		const organization = req.params.organization;

		// query parameters
		const entityName = asArray(req.query.entityName || []);
		const page = parseInt(String(req.query.page)) || defaultPage;
		const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
		const view = convertToViewType(String(req.query.view)) || defaultView;

		// Send submission data, organized by entity.
		const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByOrganization(
			categoryId,
			organization,
			{
				page,
				pageSize,
			},
			{ entityName, view },
		);

		if (!submitResult.result) {
			res.status(404).send(submitResult.metadata.errorMessage);
			return;
		}
		// Reform lyric response to include internal ID's generated by the IIM
		const formattedResult = await SanitizeLyricIdsWithInternal(submitResult.result);

		return res.status(200).send({ ...submitResult, result: formattedResult });
	} catch (error) {
		next(error);
	}
});

export const getSubmittedDataByQuery = validateRequest(dataGetByQueryRequestSchema, async (req, res, next) => {
	try {
		const categoryId = Number(req.params.categoryId);
		const organization = req.params.organization;

		// query parameters
		const entityName = asArray(req.query.entityName || []);
		const page = parseInt(String(req.query.page)) || defaultPage;
		const pageSize = parseInt(String(req.query.pageSize)) || defaultPageSize;
		const view = convertToViewType(String(req.query.view)) || defaultView;

		// Send submission data, organized by entity.
		const submitResult = await lyricProvider.services.submittedData.getSubmittedDataByOrganization(
			categoryId,
			organization,
			{
				page,
				pageSize,
			},
			{ entityName, view },
		);

		// Reform lyric response to include internal ID's generated by the IIM
		const formattedResult = await SanitizeLyricIdsWithInternal(submitResult.result);

		return res.status(200).send({ ...submitResult, result: formattedResult });
	} catch (error) {
		next(error);
	}
});

/**
 *	Function that takes in lyric SubmittedDataResponse[] and applies the transformer to all its array values
 * @returns SubmittedDataResponse replacing "data" with the sanitized sensitive fields with `internalId`
 */
const SanitizeLyricIdsWithInternal = async (submittedResult: SubmittedDataResponse[]) => {
	const db = getDbInstance();
	const iimRepo = iimService(db);
	const iimConfigs = await iimRepo.getAllIIMConfigs();
	const fieldNamesToReplace = new Set(iimConfigs.map((config) => config.fieldName));

	const formatSubmittedResult = submittedResult.map(async (result) => {
		return { ...result, data: await TransformerFunction(result.data, fieldNamesToReplace, iimRepo) };
	});

	return Promise.all(formatSubmittedResult);
};

/**
 *	Recursive function that takes in DataRecordNested and replaces sensitive entities determined from the the IIM config that was generated from the IIM service
 * @param dataRecord
 * @param fieldNames Fieldname values to replace with internalId
 * @param iimRepo iim service to query for internalId's
 * @returns Mutated Promise of DataRecordNested with field `internalId` replaced in sensitive entities
 */
const TransformerFunction = async (
	dataRecord: DataRecordNested,
	fieldNamesToReplace: Set<string>,
	iimRepo: IIMService,
) => {
	const processInternalValue = async (
		dataRecordValue: DataRecordNested,
	): Promise<DataRecordNested | DataRecordNested[]> => {
		// If the value is not an object/array or null|undefined, its a primitive value, return dataRecordValue
		if (typeof dataRecordValue !== 'object' || dataRecordValue === null || dataRecordValue === undefined) {
			return dataRecordValue;
		}

		// If its an array, then there is possible more objects to search for sensitive data, recursive call
		if (Array.isArray(dataRecordValue)) {
			return (await Promise.all(dataRecordValue.map(processInternalValue))).flat();
		}

		// Since the value is not an string | array, then that mean its object of DataRecordNested,
		const result: DataRecordNested = {};

		for (const [key, currentValue] of Object.entries(dataRecordValue)) {
			// Start sanitizing logic
			if (fieldNamesToReplace.has(key)) {
				const hashedFieldName = generateHash(`${dataRecordValue[key]}`, env.ID_MANAGER_SECRET);
				const generatedIdResult = await iimRepo.getIDByHash(hashedFieldName);

				result[key] = generatedIdResult[0]?.generatedId || 'REDACTED';
			} else {
				// FIX: currentValue is of type "DataRecordNested | DataRecordNested[] | DataRecordValue", but processInternalValue doesn't accept that even though DataRecordNested should be an acceptable type
				// eslint-disable-next-line @typescript-eslint/consistent-type-assertions
				result[key] = await processInternalValue(currentValue as DataRecordNested);
			}
		}

		return result;
	};
	return await processInternalValue(dataRecord);
};

export default {
	getDataIdExists,
	getCategoryById,
	getCategoryBySystemId,
	getCategoryByOrganization,
	getSubmittedDataByQuery,
};
